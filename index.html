<html>

<head>
    <meta name="viewport" content="width=520,user-scalable=no" />

    <title>Cloudpilot</title>
    <style>
        #rom-name {
            margin-bottom: 1rem;
        }

        #canvas {
            width: 480px;
            height: 660px;
            display: block;
            margin-top: 1rem;
            border: 1px solid black;
        }

        #canvas:focus {
            outline: none;
            border: 1px solid black;
        }

        #rom-upload,
        #file-upload {
            display: none;
        }

        #console {
            margin-top: 1rem;
            width: 100%;
            height: 15em;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            word-wrap: break-word;
            white-space: pre-line;
        }

        #buttons {
            margin-top: 1em;
        }

        .palm-button {
            display: inline-block;
            height: 3em;
            width: 52px;
            height: 52px;
            margin: 0 6px 0 0;
            padding: 0;
            border: none;
            display: inline-block;
            touch-action: manipulation;
            background: #bbb;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: nones;
        }

        .palm-button:hover,
        .palm-button:focus {
            border: none;
            outline: none;
        }

        #snapshot-indicator {
            margin-top: 1em;
        }
    </style>
</head>

<body>
    <div id="rom-name">&nbsp;</div>
    <label>
        <input type="file" id="rom-upload"></input>
        <button type="button" id="rom-upload-button">Select ROM</button>
    </label>
    <label>
        <input type="file" id="file-upload" multiple></input>
        <button type="button" id="file-upload-button">Install file</button>
    </label>
    <label>
        Username:
        <input type="text" id="input-username"></label>
    </label>
    <div id="snapshot-indicator">No snapshot saved yet</div>
    <canvas id="canvas" width="160" height="220" tabindex="1"></canvas>

    <div id="buttons">
        <button class="palm-button" type="button" data-id="app1">Cal</button>
        <button class="palm-button" type="button" data-id="app2">Phone</button>
        <button class="palm-button" type="button" data-id="app3">Todo</button>
        <button class="palm-button" type="button" data-id="app4">Notes</button>
        <button class="palm-button" type="button" data-id="rockerUp">Up</button>
        <button class="palm-button" type="button" data-id="rockerDown">Down</button>
        <button class="palm-button" type="button" data-id="cradle">Sync</button>
        <button class="palm-button" type="button" data-id="power">Power</button>
    </div>

    <pre id="console"></pre>

    <script src="src/cloudpilot.js"></script>
    <script>
        (async function () {
            const DB_NAME = 'cloudpilot-sdl';
            const OBJECT_STORE_KVS = 'kvs';
            const OBJECT_STORE_MEMORY = 'memory';

            const KEY_ROM_NAME = 'romName';
            const KEY_ROM_IMAGE = 'romImage';
            const KEY_ROM_MEMORY_SIZE = 'memorySize';
            const KEY_USERNAME = 'username';

            const romUploadButton = document.getElementById('rom-upload-button');
            const romUpload = document.getElementById('rom-upload');

            const fileUploadButton = document.getElementById('file-upload-button');
            const fileUpload = document.getElementById('file-upload');
            const usernameInput = document.getElementById('input-username');

            const romName = document.getElementById('rom-name');
            const consoleElt = document.getElementById('console');
            const canvasElt = document.getElementById('canvas');

            const snapshotIndicator = document.getElementById('snapshot-indicator');

            const KEY_PAGE_LOCK = "cloudpilot-sdl-lock";
            const PAGE_LOCK_ERROR = new Error('page opened in another tab');
            const pageLockValue = Date.now().toString() + Math.random().toString();
            localStorage.setItem(KEY_PAGE_LOCK, pageLockValue);

            function escape(text) {
                const node = document.createElement('div');

                node.innerText = text;

                return node.innerHTML;
            }

            function appendLog(msg) {
                consoleElt.innerHTML += (escape(msg) + '<br/>');
                consoleElt.scrollTop = consoleElt.scrollHeight;
            }

            class Kvs {
                constructor(db) {
                    this.db = db;
                }

                get(key) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readonly');
                    const request = transaction.objectStore(OBJECT_STORE_KVS).get(key);

                    return new Promise((resolve, reject) => {
                        request.onerror = () => reject(new Error('error reading from KVS'));
                        request.onsuccess = () => resolve(request.result);
                    })
                }

                put(key, value) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readwrite');
                    const request = transaction.objectStore(OBJECT_STORE_KVS).put(value, key);

                    return new Promise((resolve, reject) => {
                        request.onerror = () => reject(new Error('error writing to KVS'));
                        request.onsuccess = () => resolve();
                    });
                }

                delete(key) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readwrite');
                    const request = transaction.objectStore(OBJECT_STORE_KVS).delete(key);

                    return new Promise((resolve, reject) => {
                        request.onerror = () => reject(new Error('error deleting from KVS'));
                        request.onsuccess = () => resolve();
                    });
                }
            }

            class MemoryPersistence {
                constructor(db, size, module) {
                    this.db = db;
                    this.size = size;
                    this.module = module;

                    const pageCount = (size >>> 10) + (size % 1024 ? 1 : 0);
                    this.dirtyPages = new Uint8Array((pageCount >> 3) + (pageCount % 8 ? 1 : 0));

                    this.pages = new Array(pageCount);
                    for (let i = 0; i < pageCount; i++) this.pages[i] = new Int8Array(1024);

                    this.transaction = null;

                    this.dirtyPagesPtr = module.cwrap('dirtyPagesPtr', 'number', []);
                    this.memoryPtr = module.cwrap('memoryPtr', 'number', []);
                    this.uiInitialized = module.cwrap('uiInitialized', 'number', []);

                    this.intervalHandle = null;
                }

                start() {
                    if (this.intervalHandle !== null) return;

                    this.intervalHandle = setInterval(() => this.snapshotTask(), 1000);
                }

                async snapshotTask() {
                    if (this.transaction || !this.uiInitialized()) return;

                    try {
                        await this.snapshot();

                        const now = new Date();
                        snapshotIndicator.innerText = `last snapshot saved on ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
                    } catch (e) {
                        if (e === PAGE_LOCK_ERROR) {
                            this.transaction = null;
                            this.stop();

                            alert('Page opened in another tab. State in this tab will not be saved anymore.');
                        }

                        appendLog(`failed to save memory snapshot: ${(e && e.message) ? e.message : 'failed'}`);

                        snapshotIndicator.style.color = 'red';
                    }
                    finally {
                        this.transaction = null;
                    }
                }

                snapshot() {
                    return new Promise((resolve, reject) => {
                        if (localStorage.getItem(KEY_PAGE_LOCK) !== pageLockValue) {
                            throw PAGE_LOCK_ERROR;
                        }

                        let iPage = 0;
                        const dirtyPages = this.getDirtyPages();
                        const memory = this.getMemory();

                        this.transaction = this.db.transaction(OBJECT_STORE_MEMORY, 'readwrite');
                        const objectStore = this.transaction.objectStore(OBJECT_STORE_MEMORY);

                        for (let i = 0; i < dirtyPages.length; i++) {
                            this.dirtyPages[i] |= dirtyPages[i];
                            dirtyPages[i] = 0;

                            if (this.dirtyPages[i] == 0) {
                                iPage += 8;
                                continue;
                            }

                            for (let j = 0; j < 8; j++) {
                                if (this.dirtyPages[i] & (1 << j)) {
                                    this.pages[iPage].set(memory.subarray(iPage * 1024, (iPage + 1) * 1024));

                                    objectStore.put(this.pages[iPage], iPage);
                                }

                                iPage++;
                            }
                        }

                        this.transaction.oncomplete = () => {
                            this.dirtyPages.fill(0);

                            resolve();
                        }

                        this.transaction.onerror = (evt) => {
                            let msg = 'unknown error';

                            if (evt.error && evt.error.message) {
                                msg = evt.error.message;
                            } else if (event.message) {
                                msg = event.message;
                            }

                            reject(new Error(msg));
                        }
                    });
                }

                stop() {
                    if (this.transaction) {
                        this.transaction.abort();
                        this.transaction = null;
                    }

                    if (this.intervalHandle !== null) {
                        clearInterval(this.intervalHandle);
                        this.intervalHandle = null
                    }
                }

                loadMemoryImage() {
                    return new Promise((resolve, reject) => {
                        const image = new Int8Array(this.size);

                        const transaction = this.db.transaction(OBJECT_STORE_MEMORY, 'readonly');
                        const request = transaction.objectStore(OBJECT_STORE_MEMORY).openCursor();

                        request.onsuccess = () => {
                            const cursor = request.result;

                            if (!cursor) return resolve(image);

                            const page = cursor.value;
                            const iPage = cursor.key;

                            if (iPage * 1024 < this.size) {
                                image.subarray(iPage * 1024, Math.min((iPage + 1) * 1024, this.size)).set(page);
                            }

                            cursor.continue();
                        }

                        request.onerror = () => reject(new Error("failed to load memory image"));
                    })
                }

                reset() {
                    if (this.intervalHandle) {
                        throw new Error("reset called on running MemoryPersistence instance");
                    }

                    const transaction = this.db.transaction(OBJECT_STORE_MEMORY, 'readwrite');
                    transaction.objectStore(OBJECT_STORE_MEMORY).clear();

                    return new Promise((resolve, reject) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => reject(new Error('failed to clear stored memory'));
                    })
                }

                getDirtyPages() {
                    const dirtyPagesPtr = this.dirtyPagesPtr();

                    return this.module.HEAP8.subarray(dirtyPagesPtr, dirtyPagesPtr + this.dirtyPages.length);
                }

                getMemory() {
                    const memoryPtr = this.memoryPtr();

                    return this.module.HEAP8.subarray(memoryPtr, memoryPtr + this.size);
                }
            }

            const db = await openDb();
            const kvs = new Kvs(db);
            let memoryPersistence;

            let setUsernameTimeoutHandle = null;

            async function onSessionReady() {
                const nativeButtonDown = this.cwrap('buttonDown', null, ['string']);
                const nativeButtonUp = this.cwrap('buttonUp', null, ['string']);
                const nativeSetUserName = this.cwrap('setUserName', null, ['string']);

                let currentButtons = new Set();

                Array.from(document.querySelectorAll('.palm-button'))
                    .forEach(btn =>
                        ['mousedown', 'touchstart'].forEach(
                            event => btn.addEventListener(event, evt => {
                                currentButtons.add(evt.target);

                                nativeButtonDown(evt.target.dataset.id);

                                evt.preventDefault();
                            })));


                ['mouseup', 'touchend'].forEach(
                    event => window.addEventListener(event, evt => {
                        if (currentButtons.size > 0) {
                            currentButtons.forEach(btn => nativeButtonUp(btn.dataset.id));

                            currentButtons.clear();

                            evt.preventDefault();
                        }
                    }));


                usernameInput.addEventListener('change', e => {
                    if (setUsernameTimeoutHandle !== null) clearTimeout(setUsernameTimeoutHandle);

                    setUsernameTimeoutHandle = setTimeout(() => {
                        setUsernameTimeoutHandle = null;

                        kvs.put(KEY_USERNAME, e.target.value);
                        nativeSetUserName(e.target.value);
                    })
                })

                // Work around missing SDL_TEXTINPUT for option-X key combos on MacOS
                window.addEventListener(
                    'keydown',
                    e => {
                        if (e.altKey && e.key.length === 1) {
                            e.stopPropagation();
                            window.dispatchEvent(new KeyboardEvent('keydown', { altKey: false, key: e.key }));
                        }
                    },
                    true
                );

                // Hack to enable focus on the canvas element
                window.addEventListener('mousedown',
                    e => {
                        if (e.target === canvasElt) {
                            const scrollX = window.scrollX, scrollY = window.scrollY;

                            canvasElt.focus({ preventScroll: true });

                            setTimeout(() => window.scrollTo(scrollX, scrollY), 0);
                        }
                    }, true);

                const memorySize = this.ccall('memorySize', 'number', [], []);

                if (!memoryPersistence) {
                    memoryPersistence = new MemoryPersistence(db, memorySize, this);
                }
                memoryPersistence.start();

                await kvs.put(KEY_ROM_MEMORY_SIZE, memorySize);

                nativeSetUserName((await kvs.get(KEY_USERNAME)) || '');
            }

            function openDb() {
                return new Promise((resolve, reject) => {
                    const request = window.indexedDB.open(DB_NAME, 1);

                    request.onerror = e => reject(new Error('failed to open DB'));
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = () => {
                        request.result.createObjectStore(OBJECT_STORE_KVS);
                        request.result.createObjectStore(OBJECT_STORE_MEMORY);
                    }
                });
            }

            async function main(module) {
                async function launch() {
                    romName.innerText = `ROM: ${await (kvs.get(KEY_ROM_NAME))}`;

                    module.FS.writeFile('/palm.rom', await kvs.get(KEY_ROM_IMAGE));
                    const args = ['/palm.rom'];

                    if (memoryPersistence) {
                        const memoryImage = await memoryPersistence.loadMemoryImage()
                        module.FS.writeFile('/memory.bin', memoryImage);
                        args.push('/memory.bin');
                    }

                    module.callMain(args);
                }

                async function processUpload(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();

                        reader.addEventListener('load', () => resolve(new Uint8Array(reader.result)));
                        reader.addEventListener('error', () => reject(reader.error));

                        reader.readAsArrayBuffer(file);
                    });
                }

                async function onRomFileSelect(e) {
                    const file = e.target.files[0];
                    if (!file || !file.name.match(/\.rom$/i)) return;

                    const content = await processUpload(file);

                    await kvs.put(KEY_ROM_NAME, file.name);
                    await kvs.put(KEY_ROM_IMAGE, content);
                    await kvs.delete(KEY_ROM_MEMORY_SIZE);

                    if (memoryPersistence) {
                        memoryPersistence.stop();
                        await memoryPersistence.reset();
                    }

                    window.location.reload();
                }

                async function onFileUpload(e) {
                    for (const file of e.target.files) {
                        if (!file.name.match(/\.(prc|pdb)$/i)) continue;

                        const content = await processUpload(file);

                        const bufferPtr = module._malloc(content.length);
                        module.HEAP8.subarray(bufferPtr, bufferPtr + content.length).set(content);

                        module.ccall('installFile', null, ['number', 'number', 'string'], [bufferPtr, content.length, file.name]);

                        module._free(bufferPtr);
                    }
                }

                window.module = module;

                const memorySize = await (kvs.get(KEY_ROM_MEMORY_SIZE));
                if (memorySize) {
                    memoryPersistence = new MemoryPersistence(db, memorySize, module);
                }

                romUploadButton.addEventListener('click', () => romUpload.click());
                romUpload.addEventListener('change', onRomFileSelect);

                fileUploadButton.addEventListener('click', () => fileUpload.click());
                fileUpload.addEventListener('change', onFileUpload);

                if (await kvs.get(KEY_ROM_NAME) && await kvs.get(KEY_ROM_IMAGE)) {
                    await launch();
                } else {
                    romName.innerText = 'No ROM image selected';
                }
            }

            usernameInput.value = (await kvs.get(KEY_USERNAME)) || '';

            const module = await createModule({
                noInitialRun: true,
                canvas: document.getElementById('canvas'),
                print: appendLog,
                printErr: appendLog,
                sessionReady: onSessionReady
            });

            main(module);
        })()
    </script>
</body>

</html>
