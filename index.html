<html>

<head>
    <title>Cloudpilot</title>
    <style>
        #rom-name {
            margin-bottom: 1rem;
        }

        #canvas {
            width: 480px;
            height: 660px;
            display: block;
            margin-top: 1rem;
            border: 1px solid black;
        }

        #rom-upload,
        #file-upload {
            display: none;
        }

        #console {
            margin-top: 1rem;
            width: 100%;
            height: 15em;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            word-wrap: break-word;
            white-space: pre-line;
        }

        #buttons {
            margin-top: 1em;
        }

        .palm-button {
            display: inline-block;
            height: 3em;
            width: 52px;
            height: 52px;
            margin: 0 6px 0 0;
            padding: 0;
            border: none;
            display: inline-block;
            touch-action: manipulation;
            background: #bbb;
        }

        .palm-button:hover,
        .palm-button:focus {
            border: none;
            outline: none;
        }
    </style>
</head>

<body>
    <div id="rom-name">&nbsp;</div>
    <label>
        <input type="file" id="rom-upload"></input>
        <button type="button" id="rom-upload-button">Select ROM</button>
    </label>
    <label>
        <input type="file" id="file-upload" multiple accept=".prc,.pdb"></input>
        <button type="button" id="file-upload-button">Install file</button>
    </label>
    <canvas id="canvas" width="160" height="220"></canvas>

    <div id="buttons">
        <button class="palm-button" type="button" data-id="app1">Cal</button>
        <button class="palm-button" type="button" data-id="app2">Phone</button>
        <button class="palm-button" type="button" data-id="app3">Todo</button>
        <button class="palm-button" type="button" data-id="app4">Notes</button>
        <button class="palm-button" type="button" data-id="rockerUp">Up</button>
        <button class="palm-button" type="button" data-id="rockerDown">Down</button>
        <button class="palm-button" type="button" data-id="cradle">Sync</button>
        <button class="palm-button" type="button" data-id="power">Power</button>
    </div>

    <pre id="console"></pre>

    <script src="src/cloudpilot.js"></script>
    <script>
        (async function () {
            const DB_NAME = 'cloudpilot-sdl';
            const OBJECT_STORE_KVS = 'kvs';
            const OBJECT_STORE_MEMORY = 'memory';

            const KEY_ROM_NAME = 'romName';
            const KEY_ROM_IMAGE = 'romImage';
            const KEY_ROM_MEMORY_SIZE = "memorySize";

            class Kvs {
                constructor(db) {
                    this.db = db;
                }

                get(key) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readonly');
                    const request = transaction.objectStore(OBJECT_STORE_KVS).get(key);

                    return new Promise((resolve, reject) => {
                        request.onerror = () => reject(new Error('error reading from KVS'));
                        request.onsuccess = () => resolve(request.result);
                    })
                }

                put(key, value) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readwrite');
                    const request = transaction.objectStore(OBJECT_STORE_KVS).put(value, key);

                    return new Promise((resolve, reject) => {
                        request.onerror = () => reject(new Error('error writing to KVS'));
                        request.onsuccess = () => resolve();
                    });
                }
            }

            class MemoryPersistence {
                constructor(db, size, module) {
                    this.db = db;
                    this.size = size;
                    this.module = module;

                    this.dirtyPages = new Uint8Array(size >>> 13 + (size % 8192 ? 1 : 0));
                    this.snapshotInProgress = false;

                    this.dirtyPagesPtr = module.cwrap('dirtyPagesPtr', 'number', []);
                    this.memoryPtr = module.cwrap('memoryPtr', 'number', []);

                    setInterval(() => this.snapshot(), 1000);
                }

                snapshot() {
                    if (this.snapshotInProgress) return;

                    this.snapshotInProgress = true;

                    let iPage = 0;
                    const dirtyPages = this.getDirtyPages();
                    const memory = this.getMemory();
                    const transaction = this.db.transaction(OBJECT_STORE_MEMORY, 'readwrite');
                    const objectStore = transaction.objectStore(OBJECT_STORE_MEMORY);

                    for (let i = 0; i < dirtyPages.length; i++) {
                        this.dirtyPages[i] |= dirtyPages[i];
                        dirtyPages[i] = 0;

                        if (this.dirtyPages[i] == 0) {
                            iPage += 8;
                            continue;
                        }

                        for (let j = 0; j < 8; j++) {
                            if (this.dirtyPages[i] & (1 << j)) {
                                objectStore.put(memory.slice(iPage * 1024, (iPage + 1) * 1024), iPage);
                            }

                            iPage++;
                        }
                    }

                    transaction.oncomplete = () => {
                        this.dirtyPages.fill(0);
                        this.snapshotInProgress = false;
                    }

                    transaction.onerror = () => {
                        console.error('failed to save page dump');
                        this.snapshotInProgress = false;
                    }
                }

                getDirtyPages() {
                    const dirtyPagesPtr = this.dirtyPagesPtr();

                    return this.module.HEAP8.subarray(dirtyPagesPtr, dirtyPagesPtr + this.dirtyPages.length);
                }

                getMemory() {
                    const memoryPtr = this.memoryPtr();

                    return this.module.HEAP8.subarray(memoryPtr, memoryPtr + this.size);
                }
            }

            const romUploadButton = document.getElementById('rom-upload-button');
            const romUpload = document.getElementById('rom-upload');

            const fileUploadButton = document.getElementById('file-upload-button');
            const fileUpload = document.getElementById('file-upload');

            const romName = document.getElementById('rom-name');
            const consoleElt = document.getElementById('console');

            const db = await openDb();
            const kvs = new Kvs(db);
            let memoryPersistence;

            let running = false;

            function escape(text) {
                const node = document.createElement('div');

                node.innerText = text;

                return node.innerHTML;
            }

            function appendLog(msg) {
                consoleElt.innerHTML += (escape(msg) + '<br/>');
                consoleElt.scrollTop = consoleElt.scrollHeight;
            }

            async function onSessionReady() {
                const nativeButtonDown = this.cwrap('buttonDown', null, ['string']);
                const nativeButtonUp = this.cwrap('buttonUp', null, ['string']);

                let currentButton = null;

                Array.from(document.querySelectorAll('.palm-button')).forEach(btn => btn.addEventListener('mousedown', evt => {
                    currentButton = evt.target;

                    nativeButtonDown(currentButton.dataset.id);

                    evt.preventDefault();
                }));

                window.addEventListener('mouseup', evt => {
                    if (currentButton) {
                        nativeButtonUp(currentButton.dataset.id);

                        currentButton = null;

                        evt.preventDefault();
                    }
                });

                // Work around missing SDL_TEXTINPUT for option-X key combos on MacOS
                window.addEventListener(
                    'keydown',
                    e => {
                        if (e.altKey && e.key.length === 1) {
                            e.stopPropagation();
                            window.dispatchEvent(new KeyboardEvent('keydown', { altKey: false, key: e.key }));
                        }
                    },
                    true
                );

                const memorySize = this.ccall('memorySize', 'number', [], []);

                if (!memoryPersistence) {
                    memoryPersistence = new MemoryPersistence(db, memorySize, this);
                }

                await kvs.put(KEY_ROM_MEMORY_SIZE, memorySize);
            }

            function openDb() {
                return new Promise((resolve, reject) => {
                    const request = window.indexedDB.open(DB_NAME, 1);

                    request.onerror = e => reject(new Error('failed to open DB'));
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = () => {
                        request.result.createObjectStore(OBJECT_STORE_KVS);
                        request.result.createObjectStore(OBJECT_STORE_MEMORY);
                    }
                });
            }

            async function main(module) {
                async function launch() {
                    romName.innerText = `ROM: ${await (kvs.get(KEY_ROM_NAME))}`;
                    running = true;

                    module.FS.writeFile('/palm.rom', await kvs.get(KEY_ROM_IMAGE));
                    module.callMain(['/palm.rom']);
                }

                async function processUpload(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();

                        reader.addEventListener('load', () => resolve(new Uint8Array(reader.result)));
                        reader.addEventListener('error', () => reject(reader.error));

                        reader.readAsArrayBuffer(file);
                    });
                }

                async function onRomFileSelect(e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    const content = await processUpload(file);

                    await kvs.put(KEY_ROM_NAME, file.name);
                    await kvs.put(KEY_ROM_IMAGE, content);

                    if (!running) {
                        await launch();
                    } else {
                        window.location.reload();
                    }
                }

                async function onFileUpload(e) {
                    for (const file of e.target.files) {
                        const content = await processUpload(file);

                        const bufferPtr = module._malloc(content.length);
                        module.HEAP8.subarray(bufferPtr, bufferPtr + content.length).set(content);

                        module.ccall('installFile', null, ['number', 'number', 'string'], [bufferPtr, content.length, file.name]);

                        module._free(bufferPtr);
                    }
                }

                window.module = module;

                romUploadButton.addEventListener('click', () => romUpload.click());
                romUpload.addEventListener('change', onRomFileSelect);

                fileUploadButton.addEventListener('click', () => fileUpload.click());
                fileUpload.addEventListener('change', onFileUpload);

                if (await kvs.get(KEY_ROM_NAME) && await kvs.get(KEY_ROM_IMAGE)) {
                    await launch();
                } else {
                    romName.innerText = 'No ROM image selected';
                }
            }

            const module = await createModule({
                noInitialRun: true,
                canvas: document.getElementById('canvas'),
                print: appendLog,
                printErr: appendLog,
                sessionReady: onSessionReady
            });

            main(module);
        })()
    </script>
</body>

</html>
